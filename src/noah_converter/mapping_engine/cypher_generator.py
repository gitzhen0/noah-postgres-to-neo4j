"""
Cypher DDL Generator

Generates Cypher DDL statements for constraints, indexes, and schema creation.
"""

from typing import List
from .models import GraphSchema, NodeType, RelationshipType, PropertyType
from .spatial_handler import SpatialDataHandler


class CypherDDLGenerator:
    """Generate Cypher DDL statements from graph schema"""

    @staticmethod
    def generate_constraint(node: NodeType) -> str:
        """
        Generate uniqueness constraint for node primary property

        Args:
            node: NodeType definition

        Returns:
            Cypher CREATE CONSTRAINT statement
        """
        constraint_name = f"{node.label.lower()}_{node.primary_property}"

        cypher = f"""CREATE CONSTRAINT {constraint_name} IF NOT EXISTS
FOR (n:{node.label})
REQUIRE n.{node.primary_property} IS UNIQUE;"""

        return cypher

    @staticmethod
    def generate_index(node: NodeType, property_name: str) -> str:
        """
        Generate index for node property

        Args:
            node: NodeType definition
            property_name: Property to index

        Returns:
            Cypher CREATE INDEX statement
        """
        index_name = f"{node.label.lower()}_{property_name}"

        cypher = f"""CREATE INDEX {index_name} IF NOT EXISTS
FOR (n:{node.label})
ON (n.{property_name});"""

        return cypher

    @staticmethod
    def generate_all_constraints(graph_schema: GraphSchema) -> List[str]:
        """
        Generate all uniqueness constraints

        Args:
            graph_schema: Complete graph schema

        Returns:
            List of Cypher constraint statements
        """
        constraints = []

        for node in graph_schema.nodes:
            constraint = CypherDDLGenerator.generate_constraint(node)
            constraints.append(constraint)

        return constraints

    @staticmethod
    def generate_all_indexes(graph_schema: GraphSchema) -> List[str]:
        """
        Generate all indexes

        Args:
            graph_schema: Complete graph schema

        Returns:
            List of Cypher index statements
        """
        indexes = []

        for node in graph_schema.nodes:
            for prop_name in node.indexes:
                index = CypherDDLGenerator.generate_index(node, prop_name)
                indexes.append(index)

        return indexes

    @staticmethod
    def export_constraints_script(
        graph_schema: GraphSchema,
        output_path: str
    ):
        """
        Export constraints to Cypher script file

        Args:
            graph_schema: Graph schema
            output_path: Output file path
        """
        constraints = CypherDDLGenerator.generate_all_constraints(graph_schema)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("// Uniqueness Constraints\n")
            f.write("// Auto-generated by Mapping Engine\n\n")

            for constraint in constraints:
                f.write(constraint + "\n\n")

        print(f"✅ Constraints exported to {output_path}")

    @staticmethod
    def export_indexes_script(
        graph_schema: GraphSchema,
        output_path: str
    ):
        """
        Export indexes to Cypher script file

        Args:
            graph_schema: Graph schema
            output_path: Output file path
        """
        indexes = CypherDDLGenerator.generate_all_indexes(graph_schema)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("// Indexes\n")
            f.write("// Auto-generated by Mapping Engine\n\n")

            for index in indexes:
                f.write(index + "\n\n")

        print(f"✅ Indexes exported to {output_path}")

    @staticmethod
    def generate_post_migration_cypher(graph_schema: GraphSchema) -> List[str]:
        """
        Generate Cypher statements to run AFTER data migration.

        This includes:
        1. Adding Neo4j native Point properties from center_lat/center_lon
        2. Creating spatial (POINT) indexes

        Gemini: "使用 Cypher 的 point({longitude: ..., latitude: ...})
                 函数来创建节点中的原生性"
        """
        statements = []

        for node in graph_schema.nodes:
            if node.has_geometry:
                # Add Neo4j Point property
                point_cypher = SpatialDataHandler.generate_neo4j_point_cypher(node.label)
                statements.append(point_cypher)

                # Add spatial index on Point property
                index_cypher = SpatialDataHandler.generate_spatial_index_cypher(node.label)
                statements.append(index_cypher)

        return statements

    @staticmethod
    def export_post_migration_script(
        graph_schema: GraphSchema,
        output_path: str
    ):
        """
        Export post-migration Cypher script (Point creation + spatial indexes).

        Args:
            graph_schema: Graph schema
            output_path: Output file path
        """
        statements = CypherDDLGenerator.generate_post_migration_cypher(graph_schema)

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("// Post-Migration: Neo4j Point Properties & Spatial Indexes\n")
            f.write("// Run this AFTER data migration is complete\n")
            f.write("// Creates native Point type for spatial queries\n\n")

            for stmt in statements:
                f.write(stmt.strip() + "\n\n")

        print(f"✅ Post-migration script exported to {output_path}")

    @staticmethod
    def generate_node_creation_query(node: NodeType, batch_size: int = 1000) -> str:
        """
        Generate Cypher UNWIND query for batch node creation

        Args:
            node: NodeType definition
            batch_size: Batch size for UNWIND

        Returns:
            Cypher UNWIND query template
        """
        # Build property assignments
        prop_assignments = []
        for prop in node.properties:
            prop_assignments.append(f"{prop.name}: row.{prop.name}")

        props_str = ",\n    ".join(prop_assignments)

        cypher = f"""UNWIND $rows AS row
CREATE (n:{node.label})
SET n = {{
    {props_str}
}};"""

        return cypher

    @staticmethod
    def generate_relationship_creation_query(
        rel: RelationshipType
    ) -> str:
        """
        Generate Cypher query for batch relationship creation

        Args:
            rel: RelationshipType definition

        Returns:
            Cypher relationship creation query
        """
        # Property assignments for relationship
        rel_props = ""
        if rel.properties:
            prop_assignments = [f"{p.name}: row.{p.name}" for p in rel.properties]
            rel_props = " {" + ", ".join(prop_assignments) + "}"

        # Get primary properties for matching
        from_prop = "id"  # Default, should be customized
        to_prop = "id"

        cypher = f"""UNWIND $rows AS row
MATCH (from:{rel.from_label} {{{from_prop}: row.from_id}})
MATCH (to:{rel.to_label} {{{to_prop}: row.to_id}})
CREATE (from)-[r:{rel.type}{rel_props}]->(to);"""

        return cypher
